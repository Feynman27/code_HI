/***************************************************************************** 
* Project: RooFit                                                           * 
*                                                                           * 
* This code was autogenerated by RooClassFactory                            * 
*****************************************************************************/ 

 // Your description goes here... 

 #include "Riostream.h" 

 #include "RooShiftedKeysPdf.h" 
 #include "RooAbsReal.h" 
 #include "RooAbsCategory.h" 
 #include "RooRealVar.h"
 
ClassImp(RooShiftedKeysPdf) 

RooShiftedKeysPdf::RooShiftedKeysPdf(const char *name, const char *title, RooAbsReal& x, RooAbsPdf& keysPdf, RooAbsReal& shift, RooAbsReal& stretch) :
  RooAbsPdf(name,title),
  m_xProxy("m_xProxy", "m_xProxy", this, x),
  m_x(static_cast<RooRealVar*>(&x)),
  m_keysPdf(&keysPdf),
  m_shift("m_shift","m_shift", this, shift),
  m_stretch("m_stretch", "m_stretch", this, stretch)
{ 
  RooArgSet* deps = keysPdf.getDependents(*m_x);
  m_x = static_cast<RooRealVar*>(deps->find(m_x->GetName()));
  m_minValX = m_x->getMin();
  m_maxValX = m_x->getMax();
  m_mean    = getMean();
} 


RooShiftedKeysPdf::RooShiftedKeysPdf(const RooShiftedKeysPdf& other, const char* name) :  
RooAbsPdf(other,name), 
  m_xProxy("xProxy", this, other.m_xProxy),
  m_x(other.m_x),
  m_keysPdf(other.m_keysPdf),
  m_shift("m_shift", this, other.m_shift),
  m_stretch("m_stretch", this, other.m_stretch),
  m_minValX(other.m_minValX),
  m_maxValX(other.m_maxValX),
  m_mean(other.m_mean)
{ 
} 

Double_t RooShiftedKeysPdf::getMean() const {
  int nSteps       = 200;
  double step      = (m_maxValX - m_minValX)/nSteps;
  double newX      = m_minValX + step/2.0;
  double integral  = 0;
  double integralX = 0;
  
  for (int i=0; i<nSteps; i++) {
    m_x->setVal(newX);
    double pdfEval = m_keysPdf->getVal();
    integral  += pdfEval;
    integralX += pdfEval*newX;
    newX += step;
  }
  
  if (integral==0) {
    std::cerr << "WARNING: RooShiftedKeysPdf::getMean(): integral = 0, this is not causing a crash, but expect wrong results..." << std::endl;
    return 0;
  }
  else {
    std::cout << "Calculated mean of KeysPdf = " << integralX/integral << std::endl;
    return integralX/integral;
  }
  assert(1);
}

Double_t RooShiftedKeysPdf::evaluate() const 
{ 
  double shiftedX = m_xProxy - m_shift;
  double shiftedMean = m_mean - m_shift;
  double newX = (shiftedX-shiftedMean)/m_stretch + shiftedMean;
  
  if (newX<m_minValX) {
    newX = m_minValX;
  }
  if (newX>m_maxValX) {
    newX = m_maxValX;
  }
  m_x->setVal(newX);
  
  RooArgSet set(*m_x);
  double returnVal = m_keysPdf->getVal( &set );
  return returnVal; 
} 
